
 * Implement folding of arbitrary text through private unicode symbols.
 * compile rules and add as dynamic modules on-the-fly
 * isolate the meaning and syntax of what is represented by '%:': the entry point for swirl syntax.
   make it flexible.
   make simple tool which safely changes some $file o $file.swirl, escaping occurences of '%:' or whatever
 * %: https://example.com/include.swirl
 * swirl can also function as an on-the-fly preprocessor for interpreted languages.

 * library shouldnt include from /usr/local/lib/ ...

 * make backtrace userdefined... 
   * add syntax: %: (backtrace) <rule definition>
   * rule definition name must be empty
   * applies rule definition once
   * result is added to the backtrace, which will be printed on an uncaught error.
   * add syntax %: (backtrace) (pop) <warning if followed by rule definition> 
             or %: (pop) (backtrace) <warning if followed by rule definition> 

  * rusty c:
     * c, but variables are const by default
     * smart pointer
     * tagged unions
     * tuples
     * anonymous structs


 * feature to make one swirl procession unit be able to output multiple files
    - introduce new syntax:
        %: multiple_file_output_feature {%: send to :name:until_space} -> {::set_current_file_output(:name)}
    - every procession unit must therefore begin with this syntax
    - a input file to swirl is called "included file" if it does not begin with this syntax

 * after finding %:, but its neither rule definition nor file include, invoke ::swirl_main_syntax.