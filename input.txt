// optimization: grouping all anywhere applies to one

// 1 whitespace
%: 1wh {. }
%: 1wh {.
}
%: newline {.
}
// 0 whitespace
%: 0wh {}
%: nwh {}
// n whitespace
%: nwh {::1wh::nwh}

%: az {a} %: az {b} %: az {c} %: az {d} %: az {e} %: az {f} %: az {g} %: az {h} %: az {i} %: az {j} %: az {k} %: az {l} %: az {m} %: az {n} %: az {o} %: az {p} %: az {q} %: az {r} %: az {s} %: az {t} %: az {u} %: az {v} %: az {w} %: az {x} %: az {y} %: az {z}
%: AZ {A} %: AZ {B} %: AZ {C} %: AZ {D} %: AZ {E} %: AZ {F} %: AZ {G} %: AZ {H} %: AZ {I} %: AZ {J} %: AZ {K} %: AZ {L} %: AZ {M} %: AZ {N} %: AZ {O} %: AZ {P} %: AZ {Q} %: AZ {R} %: AZ {S} %: AZ {T} %: AZ {U} %: AZ {V} %: AZ {W} %: AZ {X} %: AZ {Y} %: AZ {Z}
%: aZ {::az}
%: aZ {::AZ}
%: 09 {0} %: 09 {1} %: 09 {2} %: 09 {3} %: 09 {4} %: 09 {5} %: 09 {6} %: 09 {7} %: 09 {8} %: 09 {9}

// non white space special characters
%: specialchar {.!}%: specialchar {."}%: specialchar {.#}%: specialchar {.$}%: specialchar {.%}%: specialchar {.&}%: specialchar {.'}%: specialchar {.(}%: specialchar {.)}%: specialchar {.*}%: specialchar {.+}%: specialchar {.,}%: specialchar {.-}%: specialchar {..}%: specialchar {./}%: specialchar {.:}%: specialchar {.;}%: specialchar {.<}%: specialchar {.=}%: specialchar {.>}%: specialchar {.?}%: specialchar {.@}%: specialchar {.[}%: specialchar {.\}%: specialchar {.]}%: specialchar {.^}%: specialchar {._}%: specialchar {.`}%: specialchar {.{}%: specialchar {.|}%: specialchar {.}}%: specialchar {.~}

%: alnum {::aZ}
%: alnum {::09}
%: alnum_ {_}
%: alnum_ {::alnum}
// non white space characters
%: opaquechar {::specialchar}
%: opaquechar {::alnum}
%: anychar {::1wh}
%: anychar {::opaquechar}

%: ident {::alnum_}
%: ident {::alnum_::ident}


// following meta-rule turns the following syntax:
//    apply `ruleName` anywhere.
// into rules that apply the given rule anywhere in the following text wherever it can match.
// this rule uses the namespace `ruleName`_**
%: ApplyAnywhere { apply ::nwh :ruleName:ident ::nwh anywhere ::nwh .. }
{
    apply. :ruleName. anywhere. [.
. . . . %.:. :ruleName._1applyable. {.:.:anychar.}.
. . . . %.:. :ruleName._1applyable. {.:.::ruleName.}.
. . . . %.:. :ruleName._applyable. {.}.
. . . . %.:. :ruleName._applyable. {.:.::ruleName._1applyable.:.::ruleName._applyable.}.
. . . . %.:. {.:.::ruleName._applyable.}.
    ]
}

apply ApplyAnywhere anywhere [
    %: 1applyable {::anychar}
    %: 1applyable {::ApplyAnywhere}
    %: applyable {}
    %: applyable {::1applyable::applyable}
    %: {::applyable}
]

// putting an 'x' right before balanced square brackets will erase them
%: XdBrackets {x::brackets} {}
%: brackets {[::brackets_inner]}
%: brackets_inner_1 {::not_bracket:c:anychar} {:c}
%: brackets_inner_1 {[::brackets_inner]}
%: brackets_inner {}
%: brackets_inner {::brackets_inner_1::brackets_inner}
%: not_bracket_open not {.[}
%: not_bracket_close not {.]}
%: not_bracket {::not_bracket_open::not_bracket_close}

apply XdBrackets anywhere ?

%: maybe_not {}
%: maybe_not {not}
%: not_curled_end not {.}}
%: replace_whitespace_with_nwh_1 {::not_curled_end:c:anychar} {:c}
%: replace_whitespace_with_nwh_1 {::1wh::nwh} {. .:.:1wh.:.:nwh. }
%: replace_whitespace_with_nwh {}
%: replace_whitespace_with_nwh {::replace_whitespace_with_nwh_1::replace_whitespace_with_nwh}
%: implicit_whitespace_block {
    ( ::nwh implicit ::nwh whitespace ::nwh ) ::nwh :m:maybe_not ::nwh {:result:replace_whitespace_with_nwh.}
} {
    :m. {:result.}
}

apply implicit_whitespace_block anywhere .

// generate rule that matches a string until `end` (if it has not been escaped with `esc`)
// does escape matched string.
// usage: %!: `ruleName` = any text, end with `end`, escape with `esc`
// this generator uses the namespace `ruleName`_***
%: genRuleEndText {
    %!.: ::nwh :ruleName:ident ::nwh .= ::nwh
    any ::nwh text ::nwh , ::nwh end ::nwh with ::nwh :end:anychar ::nwh , ::nwh escape ::nwh with ::nwh :esc:anychar
} {
    %.: :ruleName {.:x.:anychar.:r.::ruleName.} {.:x.:r.}
    %.: :ruleName {..:esc.:c.:anychar.:r.::ruleName.} {.:c.:r.}
    %.: :ruleName {..:end.} {.}
}

// idea how to implement namespaces with static contracts:
// a rule that wants to be the only one to use the namespace abc_**
// can formulate a static contract requiring no identifier to have this form.

// repeat innerRule 0 or more times
// %!: `ruleName` = `innerRule`*
// only uses namespace `ruleName`
%: genRuleStar (implicit whitespace) {:ruleName:ident = :innerRule:ident.*}
{
    %/!.:. :ruleName. =. :innerRule.*.
}

// repeat innerRule 1 or more times
// %!: `ruleName` = `innerRule`+
// only uses namespace `ruleName`
%: genRulePlus {%!.:::nwh:ruleName:ident::nwh.=::nwh:innerRule:ident::nwh.+} {
    %: :ruleName {.:x.::innerRule.} {.:x.}
    %: :ruleName {.:x.::innerRule.:y.::ruleName.} {.:x.:y.}
}

// repeat innerRule 1 or more times
// %!: `ruleName` = `innerRule`?
// only uses namespace `ruleName`
%: genRuleMaybe {%!.:::nwh:ruleName:ident::nwh.=::nwh:innerRule:ident::nwh.?} {
    %: :ruleName {.} {.}
    %: :ruleName {.:x.::innerRule.} {.:x.}
}

apply genRuleEndText anywhere
apply genRuleMaybe anywhere
apply genRulePlus anywhere
apply genRuleStar anywhere

manynumbers = 09*


%: {:t:manynumbers} {success. .{:t.}}7468
