%: {::lean_comment_swirl::groups_swirl::reflect_swirl}

/for all uses of ::nameless_rule below, flags aren't really supported. so maybe replace them with a checked ::unflagged_nameless_rule version./

%: maybe_nameless_rule {} -> {{}}
%: maybe_nameless_rule {::nameless_rule_arrow_notation}

%: rule_combination {::seq_chain_combination} /1<=simple/
%: rule_combination {::or_chain_combination} /2<=seq/

    %: seq_chain_combination {::rule_combination_simple}
    %: seq_chain_combination {::rule_combination_simple ::seq_chain_combination}

    %: or_chain_combination {::seq_chain_combination or ::seq_chain_combination}
    %: or_chain_combination {::seq_chain_combination or ::or_chain_combination}

    %: rule_combination_simple {::nameless_rule_arrow_notation}
    %: rule_combination_simple {(::rule_combination)::rule_postfix_op}

/unfold/ /{/
    %: unfold {-combination(:r:nameless_rule_remove_arrow_notation) -on(:prefix:c_ident) .} -> {
        %-: :prefix :r
    }

    %: unfold {-combination((:r:rule_combination)) -on(:prefix:c_ident) .} -> {
        %: {'{::unfold}'} -combination(:r) -on(:prefix).
    }

    %: unfold {-combination((:r:rule_combination)?) -on(:prefix:c_ident) .} -> {
        %-: :prefix {}
        %-: :prefix {{'::'}:prefix{''}_maybe}
        %: {{'::unfold'}} -combination(:r) -on(:prefix{''}_maybe).
    }

    %: unfold_arg_postfix {::nwh} -> {_t}
    %: unfold_arg_postfix {-postfix(:p:c_ident) ::nwh} -> {:p}

    / an example sequence chain {first}({second})+ will be unfolded on "prefix" as follows:
      first unfold the subrules:
        %: prefix_s {first}
        %: prefix_ss {second}
        %: prefix_ss {second::prefix_ss}
      then unfold the stem rule:
        %: prefix {::prefix_s::prefix_ss} /

    %: unfold {
        -combination(:head:rule_combination_simple :rest:seq_chain_combination)
        -on(:prefix:c_ident) .
    } -> {
        %: {{'::unfold_seq_subrules'}} -combination(:head :rest) -on(:prefix{''}_s).
        %: {{'::unfold_seq_stemrule'}} -combination(:head :rest) -on(:prefix).
    }

    %: unfold_seq_steminvocs (
        -combination(:head:rule_combination_simple)
        -on(:prefix:c_ident)
    ) {} -> {
        {'::'}:prefix
    }

    %: unfold_seq_steminvocs (
        -combination(:head:rule_combination_simple :rest:seq_chain_combination)
        -on(:prefix:c_ident)
    ) {
        :other_invocs:unfold_seq_steminvocs(-combination(:rest) -on(:prefix{''}s))
    } -> {
        {'::'}:prefix :other_invocs
    }


    %: unfold_seq_stemrule {
        -combination(:head:rule_combination_simple :rest:seq_chain_combination)
        -on(:prefix:c_ident) .
        :invocs:unfold_seq_steminvocs(-combination(:head :rest) -on(:prefix{''}_s))
    } -> {
        %-: :prefix {:invocs}
    }

    %: unfold_seq_subrules {
        -combination(:head:rule_combination_simple)
        -on(:prefix:c_ident) .
    } -> {
        %: {{'::unfold'}} -combination(:head) -on(:prefix).
    }

    %: unfold_seq_subrules {
        -combination(:head:rule_combination_simple :rest:seq_chain_combination)
        -on(:prefix:c_ident) .
    } -> {
        %: {{'::unfold'}} -combination(:head) -on(:prefix).
        %: {{'::unfold_seq_subrules'}} -combination(:rest) -on(:prefix{''}s).
    }

    %: unfold {
        -combination(:head:seq_chain_combination or :tail:seq_chain_combination)
        -on(:prefix:c_ident)
        :postfix:unfold_arg_postfix .
    } -> {
        %: {'{::unfold}'} -combination(:tail) -on(:prefix{''}:postfix{''}t).
        %: {'{::unfold}'} -combination(:head) -on(:prefix{''}:postfix).
        %-: :prefix {{'::'}:prefix{''}:postfix{''}t}
        %-: :prefix {{'::'}:prefix{''}:postfix}
    }

    %: unfold {
        -combination(:head:seq_chain_combination or :rest:or_chain_combination)
        -on(:prefix:c_ident)
        :postfix:unfold_arg_postfix
    } -> {
        %: {'{::unfold}'} -combination(:rest) -on(:prefix) -postfix(:postfix{''}t).
        %: {'{::unfold}'} -combination(:head) -on(:prefix{''}:postfix).
        %-: :prefix {{'::'}:prefix{''}:postfix}
    }
/}/
 
/:ruleName:c_ident = :root:rule_combination/

%: syntax_structured_rule {
    %:! {'structured:'} :ruleName:c_ident = :root:rule_combination
} -> {
    %: {'{::unfold}'} 
        -combination(:root)
        -on(:ruleName).
}


%: apply_structured_rules {}
%: apply_structured_rules {::apply_structured_rules_1::apply_structured_rules}
%: apply_structured_rules_1 {::anychar}
%: apply_structured_rules_1 {::syntax_structured_rule}

%: {--::syntax_structured_rule}

--%:! structured: c_quote = {a}{b}{c} or ({c} -> {d})?({e})


/
    %-: c_quote {"::c_quote_inner"}
    %-: c_quote_inner {}
    %-: c_quote_inner {::not_quote_char::c_quote_inner_1::c_quote_inner}
    %-: c_quote_inner_1 {::anychar}
    %-: c_quote_inner_1 {\:c:anychar} -> {:c}
    %-: not_quote_char (not) {"}
/